#include "ecg_lpf_filter.h"
#include "ecg_data_process.h"
#include "arm_const_structs.h"
//#include "bsp_loop_buffer.h"
//const float32_t fir32LP[NUM_TAPS] = {
//  -0.002440747673444,-0.0006869469814085, 0.001692348532845,0.0006181713245129,
//  0.0009128907262127, 0.005326675691079, -0.00422155352732, -0.02442149486348,
//  -0.002448918393223,   0.0546576073623,  0.03238323405778, -0.07817700917996,
//   -0.08502019403856,   0.0720232118841,   0.1380081904586, -0.02949440228581,
//     0.8425778738116, -0.02949440228581,   0.1380081904586,   0.0720232118841,
//   -0.08502019403856, -0.07817700917996,  0.03238323405778,   0.0546576073623,
//  -0.002448918393223, -0.02442149486348, -0.00422155352732, 0.005326675691079,
//  0.0009128907262127,0.0006181713245129, 0.001692348532845,-0.0006869469814085,
//  -0.002440747673444
//};

const float32_t fir32LP[NUM_TAPS] = {
  -7.484454468902e-22,-3.269336712398e-06,-1.365915864079e-05,-5.014073980636e-06,
  6.804735231975e-05,0.0001662336497003,7.965197426322e-05,-0.0003784662837741,
  -0.0008928563387901,-0.0005280588787408, 0.001284875839485, 0.003225662215767,
     0.0022425431358,-0.003157084585057,-0.009028737319977,-0.007219934929014,
   0.006057868257093,  0.02144319498633,  0.01971312591228,-0.009448071870685,
   -0.04806332586811, -0.05291973061693,  0.01224382260678,   0.1388254178822,
     0.2663085232723,   0.3199984843521,   0.2663085232723,   0.1388254178822,
    0.01224382260678, -0.05291973061693, -0.04806332586811,-0.009448071870685,
    0.01971312591228,  0.02144319498633, 0.006057868257093,-0.007219934929014,
  -0.009028737319977,-0.003157084585057,   0.0022425431358, 0.003225662215767,
   0.001284875839485,-0.0005280588787408,-0.0008928563387901,-0.0003784662837741,
  7.965197426322e-05,0.0001662336497003,6.804735231975e-05,-5.014073980636e-06,
  -1.365915864079e-05,-3.269336712399e-06,-7.484454468902e-22
};

static float32_t firStateF32[BLOCK_SIZE + NUM_TAPS - 1];


arm_fir_instance_f32 S;

void arm_fir_Init(void)
{
	arm_fir_init_f32(&S, NUM_TAPS, (float32_t *)&fir32LP[0], &firStateF32[0], BLOCK_SIZE);
}


#define MAX_COUNT 5

static float buf[MAX_COUNT]={0};    /* 数据缓冲区 */
static float sum=0;               /* N个数据的算术和 */
static int pcnt=0;                 /* 数据个数 */
static int pos=0;                 /* 缓冲区位置 */

/*
 * 滑动平均值滤波。
 * 每次新进来一个数据，就将最早进来的数据丢掉，然后计算包括新数据在内的N个数据的算术平均值。
 *
 * 每调用一次，就加入一个新数据，并得到当前的滤波值。
 */
float alg(float new_val)
{
    /* 用一个减法，就做了"丢弃最旧的数据，加入最新的数据"这一操作 */
    sum += (new_val - buf[pos]);

    buf[pos] = new_val;

    /* pos,cnt可能可以合在一起，但用两个变量，更清晰一些 */
    // pos &= 0xf;
    pos = (pos + 1) % MAX_COUNT;

    /* 个数不足时，cnt是实际个数，个数足够时，cnt最多也只是MAX_COUNT */
    //if (cnt < MAX_COUNT)
    //  cnt++;
    pcnt += (pcnt < MAX_COUNT);

    return sum / MAX_COUNT;
}



void arm_fir_f32_lp(void)
{
	
	float32_t *inputf32, *outputf32;

	if(ReadAdsInBuffer() && WriterEcgOutBuffer()){//指针定位成功
		/* 初始化输入输出缓存指针 */
		inputf32 = (float32_t *)InFifoDev.rp;
		outputf32 =(float32_t *)OutFifoDev.wp;
	  /* 初始化结构体S */
	 
	  /* 实现FIR滤波 */
		arm_fir_f32(&S, inputf32, outputf32, BLOCK_SIZE);
		
		//my_memcpy(OutFifoDev.wp,InFifoDev.rp,BLOCK_SIZE*4);
		InFifoDev.state[InFifoDev.read_front]=Empty;
		InFifoDev.read_front=(InFifoDev.read_front+1)%PACK_NUM;//切换读缓存块
	
		OutFifoDev.state[OutFifoDev.writer_rear]=Full;
		OutFifoDev.writer_rear=(OutFifoDev.writer_rear+1)%PACK_NUM;//切换写缓存块
	}

}


